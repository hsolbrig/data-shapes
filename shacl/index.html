<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset="utf-8">
		<script src="http://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "ED",
				shortName:  "shacl",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/"
					},
					{
						name:       "Arthur Ryman",
						url:        "https://ca.linkedin.com/pub/arthur-ryman/0/809/662",
						company:    "Invited Expert"
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
				wgPublicList: "public-data-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status"
			};
		</script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script> 
		<script>
		
			// Have injectPartsIntoTOC called when ReSpec is done (hack using a timer)
			var inti = setInterval(function() {
				if(window.respecEvents) {
					window.respecEvents.sub("end-all", function() {
						injectPartsIntoTOC();
					});
					clearInterval(inti);
				}
			}, 100);

			// Inject sub-headers for Part 1 and Part 2 into TOC
			injectPartsIntoTOC = function() {
				var ul = $("#respecContents");
				var first = $(ul.children()[1]);
				var middle = $(ul.children()[5]);
				var appendix = $(ul.children()[11]);
				first.before("<p class='part-header'>Part 1: Core Features</p>");
				middle.before("<p class='part-header'>Part 2: Advanced Features</p>");
				appendix.before("<p class='part-header'>Appendix</p>");
			};
		
		</script>
		<style>

			pre {
				tab-size: 4;
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.part-header {
				font-weight: bold;
			}
		
			.term {
				font-style: italic;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}
		
			.todo {
				color: red;
			}
			.practice {
				background-color: #DA81F5;
			}
			.practicelab {
				background-color: #DA81F5;
				font-weight: bold;
				font-size: 16px
			}
			.practicedesc {
				background-color: #ECE0F8;
				font-size: 14px
			}
			

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}
			
			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of RDF graphs.
				SHACL groups these descriptions and constraints into "shapes", which specify conditions that apply at a given RDF node.
				Shapes provide a high-level vocabulary to identify predicates and their associated cardinalities, datatypes and other constraints.
				Additional constraints can be associated with shapes using SPARQL and similar extension languages.
				These extension languages can also be used to define new high-level vocabulary terms.
				SHACL shapes can be used to communicate information about data structures associated with some process or interface, generate or validate data, or drive user interfaces.
				This document defines the SHACL language and its underlying semantics.
			</p>	
		</section>

		<section id="sotd">

			<h4>Revision History</h4>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes/commits/gh-pages/shacl/index.html">Git repository</a>.
			</p>
			<ul>
				<li><b>2015-09-23</b>: Multiple minor stylistic edits and corrections</li>
				<li><b>2015-09-21</b>: Added button to show or hide SPARQL definitions (thanks to Simon)</li>
				<li><b>2015-09-18</b>: Deleted <code>sh:XorConstraint</code> as resolved, renamed <code>sh:Error</code> to <code>sh:Violation</code></li>
				<li><b>2015-09-17</b>: Added missing definition of <code>sh:valueClass</code>, editorial changes, renamed sh:ClosedShape to sh:Closed, added sh:sourceTemplate</li>
				<li><b>2015-09-15</b>: Restructured Part 2, with new examples, integrated SPARQL binding and rewritten Operations section</li>
				<li><b>2015-09-14</b>: Added SPARQL definitions for each constraint type, added description of sh:hasShape function</li>
				<li><b>2015-09-11</b>: Restructured constraint section, cleaned up results vocabulary</li>
				<li><b>2015-09-10</b>: Added sh:shapesGraph property (<a href="http://www.w3.org/2014/data-shapes/track/issues/44">ISSUE-44</a>)</li>
				<li><b>2015-09-09</b>: Rewritten introduction, dropped Profile section, word-smithing on sh:valueClass</li>
				<li><b>2015-09-04</b>: Applied resolution to <a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a></li>
				<li><b>2015-09-03</b>: Many editorial changes, restructured section 5 (scopes and filters) into section 2 (Shapes)</li>
				<li><b>2015-09-01</b>: Minor changes and clarifications</li>
				<li><b>2015-08-24</b>: Added section on sh:defaultValueType (<a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a>)</li>
				<li><b>2015-08-21</b>: Added support for validation functions (<a href="http://www.w3.org/2014/data-shapes/track/issues/79">ISSUE-79</a>)</li>
				<li><b>2015-08-14</b>:
					Added qualified cardinality restrictions (<a href="http://www.w3.org/2014/data-shapes/track/issues/72">ISSUE-72</a>),
					added sh:ignoredProperties to sh:ClosedShape (<a href="http://www.w3.org/2014/data-shapes/track/issues/58">ISSUE-58</a>),
					editorial improvements to terminology, added Glossary to appendix
				</li>
				<li><b>2015-08-07</b>: Extended the use of sh:severity to template constraints, split sh:source into sh:sourceConstraint and sh:sourceShape, renamed sh:root to sh:focusNode</li>
				<li><b>2015-07-31</b>: Added sh:text as the union of xsd:string and rdf:langString</li>
				<li><b>2015-07-30</b>: Integrated sh:InversePropertyScope and sh:AllObjects</li>
				<li><b>2015-07-24</b>: Added details of XSD-like facets (<a href="http://www.w3.org/2014/data-shapes/track/issues/64">ISSUE-64</a>)</li>
				<li>
					<b>2015-07-17</b>: Rewritten scope and filter mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/62">ISSUE-62</a>),
					suggestion for generalized execution language interface (<a href="http://www.w3.org/2014/data-shapes/track/issues/60">ISSUE-60</a>)
				</li>
				<li><b>2015-07-13</b>: Replaced Appendix with references to SHACL-REF document</li>
				<li><b>2015-07-03</b>: Editorial fixes, started revision history</li>
			</ul>
			
			<h2>Document Outline</h2>
			<p>
				The sections 2 - 5 cover the <span class="term">SHACL Core Profile</span> and may be read independently from the later sections.
			</p>
			<p>
				The sections 6 onwards are about the advanced features of the SHACL language, including templates, functions, and execution semantics.
			</p>
			<p>
				The Appendix provides a <a href="#terms">Glossary of Key Concepts</a> that may also serve as a quick overview of the language.
			</p>
			<p>
				The examples in this document use Turtle [[!turtle]].
				The reader should be familiar with basic RDF concepts [[!rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[!sparql11-overview]].			<p>
			</p>
		</section>
	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				SHACL (Shapes Constraint Language) is a language for describing and constraining RDF graphs. 
				SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF datasets</a>.
				SHACL groups descriptive information and constraints that apply to a given data node into "shapes".
				This document defines what it means for an <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graph</a>, referred to as the "data graph", to conform to a SHACL program, referred to as the "shapes graph".
				Conformance can be programatically checked by processors referred to as "SHACL engines".
				The process of checking conformance is referred to as "validation".
				A shape may include a "scope" which defines which data nodes must conform to it.
				When a data node is checked for conformance to a shape, that node is referred to as the "focus node".
				The output of the validation process is a "validation report" which indicates whether or not the data graph conforms to the shapes graph.
				If any constraints are not satisfied, then the validation report will include one or more "violations" which indicate the source of the problem.
			</p>
			<p>
				For example, SHACL can be used to check whether all the nodes in a data graph that have a type link to <code>foaf:Person</code> have a single value for <code>foaf:mbox</code>, and that that value is an IRI.
				SHACL can also be used to check whether a particular node in a data graph, say the node <code>ex:bug1</code>, has at least one
				value for <code>ex:reportedBy</code> and all such values have an <code>rdf:type</code> link to <code>foaf:Person</code>.
			</p>
			<p>
				The simplest interface to a SHACL processor has two inputs:
			</p>
			<ul>
				<li>A <span class="term">data graph</span> that contains the data that is to be validated</li>
				<li>A <span class="term">shapes graph</span> containing shape definitions and other information that can be utilized to determine what validation is to be done</li>
			</ul>
			<p>
				For example, one might use SHACL to determine whether data graphs that contain information about issues and users conform to the following constraints:
				<ul>
					<li>each issue is in either an unassigned or an assigned state, and</li>
					<li>each issue has a reporter and each such reporter has a precisely one string name and one or more IRI mailboxes.</li>
				</ul>
			</p>
			<p>
				A shapes graph that defines these constraints has two shapes.
				The first, <code>ex:IssueShape</code> contains the two constraints on issues.
				The second, <code>ex:UserShape</code>, contains the two constraints on reporters.
				<code>ex:IssueShape</code> also contains scope information which in this case says that its constraints apply to all nodes that have an <code>rdf:type</code> link to <code>ex:Issue</code>.
			</p>
			<pre class="example" title="Definition of ex:IssueShape and ex:UserShape">
ex:IssueShape
	a sh:Shape ;
	sh:scopeClass ex:Issue;
	sh:property [
		sh:predicate ex:state ;
		sh:allowedValues (ex:unassigned ex:assigned) ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:reportedBy ;
		sh:valueShape ex:UserShape ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:UserShape
	a sh:Shape ;
	sh:property [
		sh:predicate foaf:name ;
		sh:datatype xsd:string ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate foaf:mbox ;
		sh:nodeKind sh:IRI ;
		sh:minCount 1 ;
	] .</pre>
			<p>
				The following data graph might be validated against this shapes graph.
			</p>
			<pre class="example" title="Definition of ex:IssueShape and ex:UserShape">
inst:Issue1
	a ex:Issue ;
	ex:state ex:unassigned ;
	ex:reportedBy inst:User2 .

inst:User2
	a foaf:Person ;
	foaf:name "Bob Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .

inst:Issue3
	a ex:Issue ;
	ex:state ex:unsinged ;
	ex:reportedBy inst:User4 .

inst:User4
	a foaf:Person ;
	foaf:name "Bob Smith", "Robert Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .</pre>
			<p>
				The SHACL validation would validate <code>ex:IssueShape</code> against <code>inst:Issue1</code> and <code>inst:Issue3</code>.
				Validating the first node would determine that <code>inst:Issue1</code> satisfies the constraints in <code>ex:IssueShape</code>, along the way determining that <code>inst:User2</code> satisfies the constraints in <code>ex:UserShape</code>.
				Validating the second node would determine that <code>inst:Issue3</code> violates the constraint on values for <code>ex:state</code>, because <code>ex:unsigned</code> is not in the list of allowed values,
				and also violates the constraint on values for <code>ex:reportedBy</code>, because <code>inst:User4</code> violates the <code>ex:UserShape</code> constraint on the maximum number of values for <code>foaf:name</code>.
			</p>
			
			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS</h3>
				<p>
					SHACL uses RDF and RDFS vocabulary (in particular <code>rdf:type</code>, <code>rdfs:Class</code>, <code>rdfs:subClassOf</code>, <code>rdfs:label</code>, <code>rdfs:comment</code>, <code>rdf:Property</code>, <code>rdf:List</code>,
					<code>rdf:langLiteral</code>, and <code>rdfs:Resource</code>) and notions (notably classes, instances, and subclasses).
					However, SHACL does not use this vocabulary or these notions in the way that they are defined in RDF and RDFS [[!rdf11-mt]].				
				</p>
				<p>
					When determining subclass and instance relationships SHACL only uses the transitive closure of <code>rdfs:subClassOf</code>,
					ignoring in particular the RDF axioms, the RDFS meaning of <code>rdfs:Resource</code>, the reflexivity of <code>rdfs:subClassOf</code>,
					the effect of subproperties of <code>rdfs:subClassOf</code>, and the effects of <code>rdfs:domain</code> and <code>rdfs:range</code>.
				</p>
				<p>
					Note that <code>rdfs:subClassOf</code> transitivity is not uniformly applied throughout SHACL.
					It is only used when SHACL explicitly determines type and subclass relationships in the shapes graph and the data.
					In other places only triples that are explicitly present in the shapes graph or the data are considered.
					For example, SHACL property constraints on <code>rdf:type</code> and <code>rdfs:subClassOf</code> only utilize triples that are explicitly in the data.
					Similarly, subproperties of <code>rdfs:label</code> and <code>rdfs:commment</code> and subclasses of <code>rdf:List</code> are not recognized in the shapes graph.
				</p>
			</section>
			
			<section id="shacl-sparql">
				<h3>Relationship between SHACL and SPARQL</h3>
				<p>
					This specification uses SPARQL 1.1 for the normative definition of the semantics of the SHACL Core constraints and scopes.
					Implementations do not have to use the exact same SPARQL queries, and do not even have to use SPARQL at all.
					However, all implementation MUST produce the same outputs for the same inputs.
				</p>
				<p>
					The SPARQL definitions in this document use the convention that the variables starting with <code>$</code> must be substituted
					with values that have been passed into the query from the outside, similar to the semantics of a VALUES clause.
				</p>
				<p>
					In some places, the specification assumes that the provided SPARQL engines are preserving the identity of blank nodes,
					so that repeated invocations of queries consistently identify and communicate the same blank nodes.
					<span class="todo">TODO: what is the best wording to make this clearer?</span>
				</p>
				<p>
					The definition of some constraints require access to a named graph represented with the variable <code>$shapesGraph</code>.
					Not all implementations (such as those using SPARQL endpoints) may be able to provide this named graph in the same dataset as the executing query.
					Such implementations may need to find alternative techniques (such as string insertion) leading to equivalent results. 
				</p>
				<p>
					The definition of some constraints assume that SPARQL engines provide a function called <code>sh:hasShape</code> as elaborated in the <a href="#constraints">beginning of section 3</a>.
					In the advanced sections, SHACL introduces mechanisms to define constraints, scopes and new functions in SPARQL.
					Implementations that only plan to cover the SHACL Core features are not required to support those mechanisms.
				</p>
				<div class="syntaxmenu">
					<p>The button below can be used to show or hide the SPARQL definitions.</p>
					<form action="">
						<p>
							<input id="hide-sparql" onclick="$('.def-sparql').css('display', 'none'); $('#hide-sparql').css('display', 'none'); $('#show-sparql').css('display', '');" type="button" value="Hide SPARQL Definitions" />
							<input id="show-sparql" onclick="$('.def-sparql').css('display', '');     $('#show-sparql').css('display', 'none'); $('#hide-sparql').css('display', '');" style="display:none" type="button" value="Show SPARQL Definitions" />
						</p>
					</form>
				</div>
			</section>
			
			<section id="namespaces">
				<h3>Namespaces</h3>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
				</table>
			</section>
			
			<section id="conformance">
				<p>
					<span class="todo">TODO: We still need to mark non-normative sections.</span>
				</p>
			</section>
			
		</section>
		
		<div style="padding-top: 30px">
			<h1 style="font-size: 160%; font-weight: bold">Part 1: Core Features</h1>
		</div>

		<section id="shapes">
			<h2>Shapes</h2>
			<p>
				In the SHACL RDF vocabulary, shapes are instances of the class <code>sh:Shape</code>.
				A <span class="term">shape</span> is a group of constraints that can be validated against nodes.
				If a node is validated against a constraint then it is called the <span class="term">focus node</span>.
				Shapes MAY have <span class="term">scopes</span> that instruct a SHACL processor on how to select those focus nodes,
				and MAY also have <span class="term">filter shapes</span> that narrow down the scope.
				For example, a shape can be used to state that all instances of a class must have a certain number of values for a given property.
				In that example, the instances of the class are the focus nodes in the scope, and the restriction on property values is expressed via a constraint.
				Both concepts are illustrated by the following figure, and introduced in the following sub-sections.
			</p>
			<figure>
				<img src="images/SHACL-Validation-Process.png" />
				<figcaption>Illustration of the scoping and filtering process</figcaption>
			</figure>
			<section id="scopes">
				<h3>Scopes</h3>
				<p>
					SHACL shapes can have three kinds of scopes:
				</p>
				<ul>
					<li><a href="#nodeShape"><b>Individual scopes</b></a> link a specific resource with a shape via <code>sh:nodeShape</code>.
					<li><a href="#scopeClass"><b>Class-based scopes</b></a> link all instances of a given class with a shape, using <code>sh:scopeClass</code> and <code>rdf:type</code>.</li>
					<li><a href="#scope"><b>General scopes</b></a> define a flexible mechanism to produce arbitrary focus nodes for a given data graph.</li>
				</ul>
				<p>
					If multiple scope definitions are present for a shape then a SHACL processor MUST use the union of the focus nodes produced by those scopes.
				</p>
				
				<section id="nodeShape">
					<h4>Individual scopes (sh:nodeShape)</h4>
					<div class="issue" data-number="61" title="Direction of sh:nodeShape">
						There is an alternative proposal discussed that would reverse the direction of this, pointing from the shape to the nodes.
					</div>
					<p>
						Individual nodes can point to the shapes that they are supposed to be validated against using the property <code>sh:nodeShape</code>.
						The values of <code>sh:nodeShape</code> must be IRIs.
						This pattern is illustrated in the following example. 				
					</p>
					<pre class="example" title="Scope based on sh:nodeShape">
ex:ExampleShape
	a sh:Shape ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	sh:nodeShape ex:ExampleShape .</pre>
				</section>
				
				<section id="scopeClass">
					<h4>Class-based Scopes (sh:scopeClass and rdf:type)</h4>
					<p>
						RDF Schema provides a well-established framework to model domains in terms of classes and instances.
						A lot of existing data is already represented this way.
						The property <code>sh:scopeClass</code> can be used to link a <code>sh:Shape</code> with an <code>rdfs:Class</code>.
						The property <code>rdf:type</code> is used to determine which shapes a given node are expected to fulfill.
						The scope includes all instances of the <code>sh:scopeClass</code> and its subclasses, by following <code>rdfs:subClassOf</code> triples.
						This pattern is illustrated in the following example.
					</p>
					<pre class="example" title="Scope based on rdf:type and sh:scopeClass">
ex:ExampleClass
	a rdfs:Class .

ex:ExampleShape
	a sh:Shape ;
	sh:scopeClass ex:ExampleClass ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	rdf:type ex:ExampleClass .</pre>
					<div class="issue" data-number="23" title="Classes and/or Shapes">
						There is no agreement in the WG on the relationship between sh:Shape and rdfs:Class.
						In the absence of such an agreement, this document uses sh:Shape in most examples but allows
						classes to be also shapes, with the class sh:ShapeClass as syntactic sugar.
					</div>
					<p>
						If the type class of an instance is also an instance of <code>sh:Shape</code> then the <code>sh:scopeClass</code> triple MAY be omitted and <code>rdf:type</code> MAY directly link a resource with its shapes.
						In this <span class="term">scope</span>, the IRIs of classes double as shape definitions, i.e. it is possible to directly link constraints to the IRI of a class.
						As syntactic sugar, the metaclass <code>sh:ShapeClass</code> can be used as a combination of <code>rdfs:Class</code> and <code>sh:Shape</code>.
						This pattern is illustrated in the following example.
					</p>
					<pre class="example" title="Scope based on rdf:type only">
ex:ExampleClassAndShape
	a rdfs:Class ;    # These two triples can be simplified via sh:ShapeClass
	a sh:Shape ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	rdf:type ex:ExampleClass .</pre>
					<div class="issue" data-number="78" title="Abstract classes">
						The following paragraph about <code>sh:abstract</code> is not yet approved by the WG.
						Options include:
						<ul>
							<li>No support of abstract classes</li>
							<li>Use <code>sh:abstract</code> entirely for documentation purposes</li>
							<li>Use <code>sh:abstract</code> also as a constraint check, possibly producing a warning</li>
						</ul>
					</div>
					<p>
						Classes with type <code>sh:ShapeClass</code> may be declared to be <span class="term">abstract</span> by
						setting their property <code>sh:abstract</code> to <code>true</code>.
						Abstract classes SHOULD not be instantiated directly, i.e. every instance of an abstract class SHOULD also
						have an <code>rdf:type</code> triple to a non-abstract subclass of the abstract class.
					</p>
				</section>
				
				<section id="scope">
					<h4>General scopes (sh:scope)</h4>
					<p>
						SHACL includes a generic mechanism to select focus nodes.
						A <code>sh:Shape</code> can point to one or more instances of <code>sh:Scope</code>.
						SHACL includes several subclasses of <code>sh:Scope</code> that define a high-level vocabulary for common scope patterns.
						The full SHACL language also includes a generic mechanism based on executable languages such as SPARQL, elaborated in an <a href="#general-scopes">advanced section</a>.
					</p>
					<section id="PropertyScope">
						<h5>Property scopes (sh:PropertyScope)</h5>
						<p>
							The scope class <code>sh:PropertyScope</code> selects all subjects that have at least one value for a given property <code>sh:predicate</code>.
							In the following SPARQL query, the variable <code>$predicate</code> is assumed to be substituted with the given value of <code>sh:predicate</code>.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this $predicate ?any .
}</pre>
						</div>
						<p>
							The following example uses <code>sh:PropertyScope</code> to define a constraint	that applies to all resources that have any value for the property <code>ex:property</code>:
						</p>
						<pre class="example" title="Shape with sh:PropertyScope">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:PropertyScope ;
		sh:predicate ex:property ;
	] ;
	sh:constraint [
		...
	] .</pre>
					</section>
					<section id="InversePropertyScope">
						<h5>Inverse property scopes (sh:InversePropertyScope)</h5>
						<p>
							The scope class <code>sh:InversePropertyScope</code> selects all objects that appear in at least one triple with a given property <code>sh:predicate</code>.
							In the following SPARQL query, the variable <code>$predicate</code> is assumed to be substituted with the given value of <code>sh:predicate</code>.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?any $predicate ?this .
}</pre>
						</div>
					</section>
					<section id="AllSubjectsScope">
						<h5>All subjects scopes (sh:AllSubjectsScope)</h5>
						<p>
							The scope class <code>sh:AllSubjectsScope</code> selects all subjects in the data graph.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this ?anyPredicate ?anyObject .
}</pre>
						</div>
						<p>
							The following example uses <code>sh:AllSubjectsScope</code> to define a constraint that shall apply to all subjects in the data graph:
						</p>
						<pre class="example" title="Shape with sh:AllSubjectsScope">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:AllSubjectsScope ;
	] ;
	sh:constraint [
		...
	] .</pre>
					</section>
					<section id="AllObjectsScope">
						<h5>All objects scopes (sh:AllObjectsScope)</h5>
						<p>
							The scope class <code>sh:AllObjectsScope</code> selects all objects in the data graph, unless they are literals.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?anySubject ?anyPredicate ?this .
	FILTER (!isLiteral(?this)) .
}</pre>
						</div>
					</section>
				</section>
			</section>
			
			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					In some cases, constraints should not apply to all focus nodes, produced by a scope.
					For example, instances of the given class <code>ex:Person</code> that were <code>ex:bornIn</code>
					the country <code>ex:USA</code> may have a different legal drinking age than others.
					In order to support such use cases, SHACL includes the concept of <span class="term">filter shapes</span> that act as pre-conditions that all focus nodes need to fulfill before they are being validated.
					Formally, filter shapes eliminate entries from the collection of focus nodes selected by a shape's scopes, if the focus node produces a validation result with severity <code>sh:Violation</code> or a failure for the given filter shapes.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint only applies to resources that have a certain value for <code>ex:requiredProperty</code>. 
				</p>
				<pre class="example" title="Constraint with a filter shape">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:filterShape [
			a sh:Shape ; # Optional triple
			sh:property [
				sh:predicate ex:requiredProperty ;
				sh:hasValue ex:requiredValue ;
			]
		] ;
	] .

ex:FilteredShapeValidExampleInstance
	ex:someProperty ex:someValue ;
	ex:requiredProperty ex:requiredValue .</pre>
			<p>
				Alternatively, <code>sh:filterShape</code> can be defined for a whole shape, with the meaning
				that the filter applies to all constraints defined by the shape, as shown in the following example.
			</p>
			<pre class="example" title="Shape with a filter shape">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:filterShape [
		sh:property [
			sh:predicate ex:requiredProperty ;
			sh:hasValue ex:requiredValue ;
		]
	] ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
	] .

ex:FilteredShapeValidExampleInstance
	ex:someProperty ex:someValue ;
	ex:requiredProperty ex:requiredValue .</pre>
				<div class="issue" data-number="49" title="Do filters apply to sh:valueShape etc">
					It is still undecided whether filters shall also be applied for shapes that are directly invoked, e.g. via sh:valueShape.
				</div>
				<p>
					The following figure illustrates some relationships between core classes of SHACL and RDF Schema.
					Note that the use of a UML-like notation does not imply that these RDF concepts are classes in an object-oriented sense.
				</p>
 				<figure>
					<img src='images/shacl-class-metamodel.png'>
					<figcaption>Illustration of some relationships between classes of SHACL and RDF Schema</figcaption>
				</figure>
			</section>
			<section id="shape-constraints">
				<h3>Constraints</h3>
				<p>
					A shape defines a group of constraints.
					SHACL includes a collection of Core constraint types that are covered in the next section.
					Additional types of constraints can be added using the <a href="#template-constraints">extension mechanism</a>.
				</p>
				<p>
					Shapes can be linked to their constraints via the following properties:
				</p>
				<ul>
					<li>
						<code>sh:property</code> links a shape with constraints about a given property of the focus node.
						These constraints are called <a href="#constraints-property"><span class="term">property constraints</span></a>.
					</li>
					<li>
						<code>sh:inverseProperty</code> links a shape with constraints about a given property traversed in the inverse direction of the focus node.
						These constraints are called <a href="#constraints-inverse-property"><span class="term">inverse property constraints</span></a>.
					</li>
					<li>
						<code>sh:constraint</code> link a shape with constraints that do not involve just a single dedicated property.
						SHACL includes <a href="#constraints-property-pair"><span class="term">property pair constraints</span></a> and
						<a href="#constraints-other">other constraints</a> such as logical operators.
					</li>
				</ul>
			</section>
		</section>
		
		<section id="constraints">
			<h2>Core Constraint Types</h2>
			<p>
				The following sections define the constraint types built into the SHACL Core.
				Compliant SHACL engines MUST support all of these constraints.
			</p>
			<p>
				Note that the textual definitions of the constraint types refer to the <a href="#results">Validation Results Vocabulary</a>
				introduced in a later section.
			</p>
			<p>
				The SPARQL definitions in this section assume the following variable bindings:
			</p>
			<ul>
				<li>The variable <code>$this</code> is assumed to point at the current focus node.</li>
				<li>The variable <code>$shapesGraph</code> points at the IRI of the <span class="term">shapes graph</span> in the current dataset.</li>
				<li>The variable <code>$currentShape</code> points at the currently evaluated shape.</li>
			</ul>
			<p>
				Each row in the result set of the SPARQL queries in this document represents one <span class="term">validation result</span>.
				The other variables in the SELECT clause are mapped to the details of each <a href="#results">validation result</a>, e.g. <code>?object</code> is mapped to <code>sh:object</code>.
				<span class="todo">(Clarify what exact compliance level is required, e.g. do they need to produce focus nodes)</span>
				If a row in a SPARQL result set produces <code>true</code> as value for the variable <code>?failure</code> then a <span class="term">failure</span> must be reported.
			</p>
			<p>
				The SPARQL definitions in this section also assume the existence of a built-in SPARQL function <code>sh:hasShape</code>, which takes the following arguments:
			</p>
			<table class="term-table" border="1" cellpadding="5">
				<tr>
					<th style="min-width: 200px">Argument</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>?focusNode</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The focus node to validate.</td>
				</tr>
				<tr>
					<td><code>?shape</code></td>
					<td><code>sh:Shape</code></td>
					<td>The shape to validate the focus node against.</td>
				</tr>
				<tr>
					<td><code>?shapesGraph</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The current <span class="term">shapes graph</span>.</td>
				</tr>
				<tr>
					<td><code>?recursionIsError</code></td>
					<td><code>xsd:boolean</code></td>
					<td>
						If set to <code>true</code> then any recursive occurrence of the same resource against the same shape signals a failure,
						with the function returning <span class="term">undefined</span>.
						If not <code>true</code> then any recursive occurrence must return <code>true</code>.
					</td>
				</tr>
			</table>
			<p>
				The result of the <code>sh:hasShape</code> function is either <code>true</code>, <code>false</code> or <span class="term">undefined</span>.
				The function returns <code>true</code> if the validation of the <code>?focusNode</code> against the given <code>?shape</code> produces no validation results with severity <code>sh:Violation</code>.
				The validation algorithm of <code>sh:hasShape</code> itself is based the <a href="#operation-validateNodeAgainstShape"><code>validateNodeAgainstShape</code> operation</a>.
				Note that any validation results produced inside of the <code>sh:hasShape</code> function are temporary, i.e. they are not added to the results graph of the surrounding execution environment.
				However, some implementations may add those nested validation results as annotations to the surrounding validation results, via <a href="#results-detail"><code>sh:detail</code></a>.
			</p>

			<section id="constraints-property">
				<h3>Property Constraints (sh:property)</h3>
				<p>
					A <span class="term">property constraint</span> is a constraint that defines restrictions on the values of a given property in the context of the focus node.
					Here, the focus node is the <span class="term">subject</span> and the property is the <span class="term">predicate</span> of relevant triples.
					The property <code>sh:property</code> can be used to link a shape with its property constraints.
				</p>
				<p>
					In SHACL, property constraints are assumed to  instances of the class <code>sh:PropertyConstraint</code>.
					<div class="practice">
						<p>
						<span id="propertyConstraintType" class="praticelab">Typing property constraints</span>
						</p>
						<p class="practicedesc">
							When used as values of <code>sh:property</code>, property constraints do not require an <code>rdf:type</code> triple.
							However, if those values are IRIs, then they SHOULD have an <code>rdf:type</code> triple.
							Note that <code>sh:property</code> may also have values that are sub-classes of <code>sh:PropertyConstraint</code>,
							but in this case the <code>rdf:type</code> triple is required.
							It is not valid to use <code>sh:property</code> for constraints that are not instance of <code>sh:PropertyConstraint</code>.
						</p>
					</div>
				</p>
				<p> 
					The following examples illustrate two ways of using property constraints.
					The first example uses a blank node:
				</p>
				<pre class="example" title="Property constraint represented by a blank node">
ex:InlinePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:valueClass ex:SomeClass ;
		rdfs:label "some property" ;
		rdfs:comment "Description of the role of ex:someProperty (in the context of the constraint)" ;
	] .</pre>
				<p>
					The second example defines a constraint as an IRI node, allowing it to be more easily referenced and shared across multiple shapes:
				</p>
				<pre class="example" title="Property constraint represented by a IRI">
ex:StandAlonePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property ex:StandAloneConstraint .

ex:StandAloneConstraint
	a sh:PropertyConstraint ;
	sh:predicate ex:someProperty ;
	sh:defaultValue ex:SomeInstance ;
	sh:minCount 1 ;
	sh:valueClass ex:SomeClass .</pre>
				<p>
					Property constraints may have an <code>rdfs:label</code> to provide a human-readable label for the property	in the scope where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					For example, if a form displays a resource that is in the scope of a given shape, and the shape defines a <code>sh:property</code> constraint with an <code>rdfs:label</code>, then the tool SHOULD use the provided label.
					Similarly, property constraints may have an <code>rdfs:comment</code> to provide a description of the property in the given context.
					Both <code>rdfs:label</code> and <code>rdfs:comment</code> may have multiple values, but SHOULD only have one value per language tag.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but MAY be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code>, <code>sh:directValueType</code> or <code>sh:valueClass</code> of the same constraint.
				</p>
				<p>
					The following sections provide details on the properties that may be used with <code>sh:PropertyConstraint</code>.
					None of these properties can be repeated within the same <code>sh:PropertyConstraint</code>.
					In order to define multiple constraints using the same property, such as multiple <code>sh:hasValue</code> constraints, the shape must use multiple <code>sh:property</code> definitions.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Properties</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><a href="#AbstractAllowedValuesPropertyConstraint"><code>sh:allowedValues</code></a></td>
						<td>Enumeration of allowed values</td>
					</tr>
					<tr>
						<td><a href="#AbstractDatatypePropertyConstraint"><code>sh:datatype</code></a></td>
						<td>Datatype of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractHasValuePropertyConstraint"><code>sh:hasValue</code></a></td>
						<td>A specific required value</td>
					</tr>
					<tr>
						<td><a href="#AbstractCountPropertyConstraint"><code>sh:minCount</code>, <code>sh:maxCount</code></a></td>
						<td>Minimum and maximum cardinality</td>
					</tr>
					<tr>
						<td><a href="#AbstractLengthPropertyConstraint"><code>sh:minLength</code>, <code>sh:maxLength</code></a></td>
						<td>Minimum and maximum string length</td>
					</tr>
					<tr>
						<td><a href="#AbstractMaxExclusivePropertyConstraint"><code>sh:maxExclusive</code></a></td>
						<td>Maximum exclusive value (&gt;)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMaxInclusivePropertyConstraint"><code>sh:maxInclusive</code></a></td>
						<td>Maximum inclusive value (&gt;=)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMinExclusivePropertyConstraint"><code>sh:minExclusive</code></a></td>
						<td>Minimum exclusive value (&lt;)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMinInclusivePropertyConstraint"><code>sh:minInclusive</code></a></td>
						<td>Minimum inclusive value (&lt;=)</td>
					</tr>
					<tr>
						<td><a href="#AbstractNodeKindPropertyConstraint"><code>sh:nodeKind</code></a></td>
						<td>Node kind (IRI, blank node, or literal) of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractPatternPropertyConstraint"><code>sh:pattern</code></a></td>
						<td>Regular expression string matching</td>
					</tr>
					<tr>
						<td>
							<a href="#AbstractValueClassPropertyConstraint"><code>sh:valueClass</code></a> and
							<a href="#AbstractDirectValueTypePropertyConstraint"><code>sh:directValueType</code></a>
						</td>
						<td>Type of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractValueShapePropertyConstraint"><code>sh:valueShape</code></a></td>
						<td>Nested shape of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractQualifiedValueShapePropertyConstraint"><code>sh:qualifiedValueShape</code>, <code>sh:qualifiedMinCount</code>, <code>sh:qualifiedMaxCount</code></a></td>
						<td>Nested shape of a given minimum/maximum number of values</td>
					</tr>
				</table>
				<section id="AbstractAllowedValuesPropertyConstraint">
					<h4>sh:allowedValues</h4>
					<p>
						The property <code>sh:allowedValues</code> can be used to enumerate the values a property can have.
						When specified, the value of the given property must be members of the specified set.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:allowedValues</code></td>
							<td><code>rdf:List</code></td>
							<td>Enumeration of allowed values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:allowedValues</code> must be well-formed instances of <code>rdf:List</code>.
							The members of that <code>rdf:List</code> must not be blank nodes.
							A <span class="term">validation result</span> must be produced for every triple that has the <span class="term">focus node</span> as its subject,
							the <code>sh:predicate</code> as its predicate and an object that is not a member of the given list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
							Each produced <span class="term">result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective invalid value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		GRAPH $shapesGraph {
			$allowedValues (rdf:rest*)/rdf:first ?value .
		}
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:allowedValues constraint">
ex:AllowedValuesExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:allowedValues ( ex:Value1 ex:Value2 ex:Value3 ) ;
	] .

ex:AllowedValuesExampleValidResource
	ex:someProperty ex:Value2 .</pre>
				</section>
				<section id="AbstractDatatypePropertyConstraint">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all values of the given property.
						The values of <code>sh:datatype</code> must be instances of the class <code>rdfs:Datatype</code>, such as <code>xsd:string</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdfs:Datatype</code></td>
							<td>Datatype of all values (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is not a literal, or is a literal with a mismatching datatype.
							A literal matches a datatype if the literal's datatype has the same IRI,
							or if its datatype is <code>rdf:langLiteral</code> or <code>xsd:string</code> and the expected datatype is <a href="../shacl-ref/#text"><code>sh:text</code></a>.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		{
			FILTER isLiteral(?value) .
		} .
		BIND (datatype(?value) AS ?valueDatatype) .
		FILTER ((?valueDatatype = $datatype) || ($datatype = sh:text &amp;&amp; ?valueDatatype IN (rdf:langString, xsd:string))) .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:datatype constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatype sh:text ;
	] .

ex:DatatypeShapeExampleValidResource
	ex:someProperty "Some value" ;
	ex:someProperty "Value with language tag"@en .

ex:DatatypeShapeExampleInvalidResource
	ex:someProperty 42 .</pre>
				</section>
				<section id="AbstractDirectValueTypePropertyConstraint">
					<h4>sh:directValueType</h4>
					<p>
						The property <code>sh:directValueType</code> can be used to restrict the <code>rdf:type</code> of all values of the given property.
						The values of <code>sh:directValueType</code> must be classes (instances of <code>rdfs:Class</code>).
						The main difference with <a href="#AbstractValueClassPropertyConstraint"><code>sh:valueClass</code></a> is that <code>sh:directValueType</code> does not include subclasses of the type.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:directValueType</code></td>
							<td><code>rdfs:Class</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not have an <code>rdf:type</code> triple with the given value type as object.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		?value a $directValueType .
	}
}</pre>
					</div>
				</section>
				<section id="AbstractHasValuePropertyConstraint">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify
						that the <span class="term">focus node</span> has a given RDF node among the values of the given
						predicate.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>any</td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if there is no triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and the <code>sh:hasValue</code> as its object.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	FILTER NOT EXISTS {
		$this $predicate $hasValue .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:hasValue constraint">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .

ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
				</section>
				<section id="AbstractCountPropertyConstraint">
					<h4>sh:minCount, sh:maxCount</h4>
					<p>
						The properties <code>sh:minCount</code> and <code>sh:maxCount</code>
						restrict the number of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>. 
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum cardinality. Default value is 0.</td>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum cardinality. Default interpretation is unlimited.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The default value of <code>sh:minCount</code> is 0.
							Let <code>?count</code> be the number of triples that have the <span class="term">focus node</span> as
							the <span class="term">subject</span> and the <code>sh:predicate</code> as the <span class="term">predicate</span>.
							A <span class="term">validation result</span> must be produced in either of the following cases:
							If <code>?count</code> is less than the value of <code>sh:minCount</code>, or
							if <code>sh:maxCount</code> is present and <code>?count</code> is greater than the value of <code>sh:maxCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the predicate as its <code>sh:predicate</code>. 
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &lt; $minCount || (bound($maxCount) &amp;&amp; ?count &gt; $maxCount))
}</pre>
					</div>
					<pre class="example" title="Shape with sh:minCount and sh:maxCount constraints">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
				<section id="AbstractLengthPropertyConstraint">
					<h4>sh:minLength, sh:maxLength</h4>
					<p>
						The properties <code>sh:minLength</code> and <code>sh:maxLength</code>
						restrict the string length of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						This can be applied to any type of literal and IRIs, but not for blank nodes.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum length. Default value is 0.</td>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum length. Default interpretation is unlimited.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The default value of <code>sh:minLength</code> is 0.
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the length of the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							of the object is either less than the specified minimum length or more than the specified maximum length, or if the object is a blank node.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		BIND (STRLEN(str(?value)) AS ?valueLength) .
		FILTER (bound(?valueLength) &amp;&amp; 
			(?valueLength &gt;= COALESCE($minLength, 0)) &amp;&amp;
			(!bound($maxLength) || ?valueLength &lt;= $maxLength)) .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:minLength and sh:maxLength constraints">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
		rdfs:comment "Password must be between 8 and 10 characters long" ;
	] .

ex:PasswordExampleValidResource
	ex:password "password" .</pre>
				</section>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						The supported datatypes of these properties are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="AbstractMinExclusivePropertyConstraint">
							<td><code>sh:minExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code></td>
						</tr>
						<tr id="AbstractMinInclusivePropertyConstraint">
							<td><code>sh:minInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code></td>
						</tr>
						<tr id="AbstractMaxExclusivePropertyConstraint">
							<td><code>sh:maxExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code></td>
						</tr>
						<tr id="AbstractMaxInclusivePropertyConstraint">
							<td><code>sh:maxInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <span class="term">validation result</span> must also be produced if the object cannot be compared to the specified range.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the engine will produce a validation result.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<p>
						The following SPARQL definition covers <code>sh:minExclusive</code> - the other variations can be derived by replacing the <code>&gt;</code> operator.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!($value &gt; $minExclusive)) .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:minInclusive and sh:maxInclusive constraints">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minInclusive 1 ;
		sh:maxInclusive 10 ;
	] .

ex:NumericExampleValidResource
	ex:someProperty 7 .

ex:NumericExampleInvalidResource1
	ex:someProperty 11 .

ex:NumericExampleInvalidResource2
	ex:someProperty "a string" .</pre>
				</section>
				<section id="AbstractNodeKindPropertyConstraint">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> can be used to restrict the RDF node kind of all values of the given property.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td><code>sh:NodeKind</code></td>
							<td>Node kind (IRI, blank node, or literal) of all values</td>
						</tr>
					</table>
					<p>
						The values of <code>sh:nodeKind</code> must be instances of the class <code>sh:NodeKind</code>.
						The SHACL system vocabulary defines that <code>sh:NodeKind</code> has exactly 3 instances:
						<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code> (see also the <a href="#function-hasNodeKind">Appendix</a>).
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the given node kind.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		FILTER ((isIRI(?value) &amp;&amp; $nodeKind = sh:IRI) ||
			(isLiteral(?value) &amp;&amp; $nodeKind = sh:Literal) ||
			(isBlank(?value) &amp;&amp; $nodeKind = sh:BlankNode)) .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:nodeKind constraint">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:nodeKind ex:IRI ;
	] .

ex:NodeKindShapeExampleValidResource
	ex:someProperty ex:SomeIRI .

ex:NodeKindShapeExampleInvalidResource
	ex:someProperty ex:SomeIRI ;
	ex:someProperty "A literal" .</pre>
				</section>
				<section id="AbstractPatternPropertyConstraint">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to validate whether all values of the given property match a given regular expression.
						The values of <code>sh:pattern</code> must be valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td><code>xsd:string</code></td>
							<td>Regular expression that all values must match</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							of the object does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || !regex(str(?value), $pattern)) .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:pattern constraint">
ex:PatternExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:pattern "^Ali" ;
	] .

ex:PatternShapeExampleValidResource
	ex:someProperty "Alice" .

ex:PatternShapeExampleInvalidResource
	ex:someProperty "The Alice" .</pre>
				</section>
				<section id="AbstractValueClassPropertyConstraint">
					<h4>sh:valueClass</h4>
					<p>
						The property <code>sh:valueClass</code> can be used to verify that each value of the given property is an instance of a given type. 
						The values of <code>sh:valueClass</code> must be classes (instances of <code>rdfs:Class</code>).
						The main difference with <a href="#AbstractDirectValueTypePropertyConstraint"><code>sh:directValueType</code></a> is that <code>sh:valueClass</code> also includes subclasses of the type.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:valueClass</code></td>
							<td><code>rdfs:Class</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if it has an <code>rdf:type</code> value that is the type or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code>.
							If the value class is <code>rdfs:Resource</code> then all resources match, including untyped resources.
							Finally, if the value class is <code>rdf:List</code> then the object matches if it has an <code>rdf:first</code> triple.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isLiteral(?value) || 
		!(
			$valueClass = rdfs:Resource ||
			($valueClass = rdf:List &amp;&amp; EXISTS { $value rdf:first ?any }) ||
			EXISTS { $value rdf:type/rdfs:subClassOf* $valueClass }
		))
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:valueClass constraint">
ex:ValueClassExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueClass ex:ClassA ;
	] .
	
ex:InstanceOfClassA
	a ex:ClassA .

ex:ValueClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA .</pre>
				</section>
				<section id="AbstractValueShapePropertyConstraint">
					<h4>sh:valueShape</h4>
					<p>
						The property <code>sh:valueShape</code> can be used verify that all values of the given property must have a given shape.
						The value type of <code>sh:valueShape</code> is <code>sh:Shape</code>, but the <code>rdf:type</code> triple of those shapes can be omitted.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:valueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:valueShape</code> 
							produces any validation results with severity <code>sh:Violation</code> or a failure.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object ?failure
WHERE {
	$this $predicate ?object .
	BIND (sh:hasShape(?object, $valueShape, $shapesGraph, false) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || !?hasShape) .
}</pre>
					</div>
					<p class="issue" data-number="22" title="Recursion of sh:valueShape">
						It is not yet decided how to handle recursive shape definitions in sh:valueShape and similar constructs.
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> are supposed to validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example" title="Shape with sh:valueShape constraint">
ex:ValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueShape [
			a sh:Shape ;   # Optional
			sh:predicate [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .

ex:ValueShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				<section id="AbstractQualifiedValueShapePropertyConstraint">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a certain number  of values of the given property must have a given shape.
						The value type of <code>sh:qualifiedValueShape</code> is <code>sh:Shape</code>, and it needs to be accompanied by
						a <code>sh:qualifiedMinCount</code> or a <code>sh:qualifiedMaxCount</code> (both typed <code>xsd:integer</code>), or both.
						The <code>rdf:type</code> of the value shapes can be omitted.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of the specified values</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum number of values that must have the shape</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum number of values that can have the shape</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of triples that have
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no validation results with severity <code>sh:Violation</code> or a failure is outside of the interval specified by <code>sh:qualifiedMinCount</code> and <code>sh:qualifiedMaxCount</code>.
							The interval defaults to <code>0</code> if the min count is not specified, and unlimited if the max count is not specified.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				FILTER EXISTS { $this $predicate ?value } .
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph, true) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ((?count &lt; $qualifiedMinCount) || (bound($qualifiedMaxCount) &amp;&amp; (?count &gt; $qualifiedMaxCount)))) .
}</pre>
					</div>
					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example" title="Shape with sh:qualifiedValueShape constraint">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .

ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>
			</section>
			
			<section id="constraints-inverse-property">
				<h3>Inverse Property Constraints (sh:inverseProperty)</h3>
				<p class="todo">
					TODO: This section is quite similar to the one about sh:property, only in the inverse direction.
					Before writing all this down, we'd rather wait until the forward direction has stabilized.
					A quick example should suffice for now:
				</p>
				<pre class="example" title="Shape with an inverse property constraint">
ex:InversePropertyConstraintExampleShape
	a sh:Shape ;
	sh:inverseProperty [
		sh:predicate ex:someProperty ;  # e.g. "child"
		sh:minCount 1 ;
		rdfs:label "is someProperty of" ;  # e.g. "parent"
	] .</pre>
			</section>
			
			<section id="constraints-property-pair">
				<h3>Property Pair Constraints</h3>
				<p>
					SHACL includes a collection of constraint types that are about a given pair of properties at the same focus node.
					All constraint types in this section take the following arguments:
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Property</th>
						<th>Value Type</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><code>sh:predicate1</code></td>
						<td><code>rdf:Property</code></td>
						<td>The first property being constrained.</td>
					</tr>
					<tr>
						<td><code>sh:predicate2</code></td>
						<td><code>rdf:Property</code></td>
						<td>The second property being constrained.</td>
					</tr>
				</table>
				<p>
					The values of <code>sh:predicate1</code> and <code>sh:predicate2</code> must be distinct.
				</p>
				<section id="EqualConstraint">
					<h3>sh:EqualConstraint</h3>
					<p>
						The <code>sh:EqualConstraint</code> constrains a pair of properties so that the value sets of both properties at a given focus node must be equal.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced
							for each value of <code>sh:predicate1</code> that does not exist as value of <code>sh:predicate2</code> and
							for each value of <code>sh:predicate2</code> that does not exist as value of <code>sh:predicate1</code>
							at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the corresponding values of the existing triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ?predicate ?object
WHERE {
	{
		$this $predicate1 ?object .
		FILTER NOT EXISTS {
			$this $predicate2 ?object .
		}
		BIND ($predicate1 AS ?predicate) .
	}
	UNION
	{
		$this $predicate2 ?object .
		FILTER NOT EXISTS {
			$this $predicate1 ?object .
		}
		BIND ($predicate2 AS ?predicate) .
	}
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:EqualConstraint</code> in a shape to verify
						that certain nodes must have the same value sets for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<pre class="example" title="Shape with an sh:EqualsConstraint">
ex:EqualExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:EqualsConstraint ;
		sh:predicate1 ex:firstName ;
		sh:predicate2 ex:givenName ;
	] .

ex:ValidInstance1
	ex:firstName "John" ;
	ex:givenName "John" .</pre>
				</section>
				<section id="NotEqualConstraint">
					<h3>sh:NotEqualConstraint</h3>
					<p>
						The <code>sh:NotEqualConstraint</code> constrains a pair of properties so that the value sets of both properties at a given focus node must not share any values.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each value of <code>sh:predicate1</code>
							that also exists as value of <code>sh:predicate2</code> at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate1</code> as its <code>sh:predicate</code> and the value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ($predicate1 AS ?predicate) ?object
WHERE {
	$this $predicate1 ?object .
	$this $predicate2 ?object .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:NotEqualConstraint</code> in a shape to verify
						that certain nodes must not share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<pre class="example" title="Shape with an sh:NotEqualConstraint">
ex:NotEqualExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:NotEqualsConstraint ;
		sh:predicate1 ex:prefLabel ;
		sh:predicate2 ex:altLabel ;
	] .

ex:ValidInstance1
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

ex:InvalidInstance1
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .</pre>
				</section>
				<section id="LessThanConstraint">
					<h3>sh:LessThanConstraint</h3>
					<p>
						The <code>sh:LessThanConstraint</code> constrains a pair of properties so that the values of the first property must be smaller than the values of the second property at a given focus node.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate1</code>
							and <code>sh:predicate2</code> at the given <span class="term">focus node</span>, where
							the first value is not less than the second value, based on SPARQL's <code>&lt;</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate1</code> as its <code>sh:predicate</code> and the value of the first predicate as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ($predicate1 AS ?predicate) ?object
WHERE {
	$this $predicate1 ?object .
	$this $predicate2 ?object2 .
	FILTER (!(?object &lt; ?object2)) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:LessThanConstraint</code> in a shape to verify
						that all values of <code>ex:startDate</code> must "before" the values of <code>ex:endDate</code>.
					</p>
					<pre class="example" title="Shape with an sh:LessThanConstraint">
ex:LessThanExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:LessThanConstraint ;
		sh:predicate1 ex:startDate ;
		sh:predicate2 ex:endDate ;
	] .</pre>
				</section>
				<section id="LessThanOrEqualConstraint">
					<h3>sh:LessThanOrEqualConstraint</h3>
					<p>
						The <code>sh:LessThanOrEqualConstraint</code> constrains a pair of properties so that the values of the first property must be smaller than or equal to the values of the second property at a given focus node.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate1</code>
							and <code>sh:predicate2</code> at the given <span class="term">focus node</span>, where
							the first value is not less than or equal to the second value, based on SPARQL's <code>&lt;=</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate1</code> as its <code>sh:predicate</code> and the value of the first predicate as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ($predicate1 AS ?predicate) ?object
WHERE {
	$this $predicate1 ?object .
	$this $predicate2 ?object2 .
	FILTER (!(?object &lt;= ?object2)) .
}</pre>
					</div>
				</section>
			</section>
			
			<section id="constraints-other">
				<h2>Other Core Constraints</h2>
				<p>
					While the previous sections have introduced constraints that focused on a single property within a shape,
					this section introduces other constraint types that can be used with shapes.
				</p>
				<section id="not">
					<h3>sh:NotConstraint</h3>
					<p>
						SHACL supports a high-level negation constraint that can be used to verify that the <span class="term">focus node</span> does not have a given shape.
						This is comparable to a logical "not" operator.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:shape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The shape to negate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the <span class="term">focus node</span> produces no validation results with severity <code>sh:Violation</code> for the shape given via <code>sh:shape</code>.
							A <span class="term">failure</span> must be reported if the validation of the shape produces a failure.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	BIND (sh:hasShape($this, $shape, $shapesGraph, true) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || ?hasShape) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:NotConstraint</code> in a shape to verify
						that certain nodes cannot have any value of <code>ex:property</code>.
					</p>
					<pre class="example" title="Shape with a negation">
ex:NotExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:NotConstraint ;
		sh:shape [
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:minCount 1 ;
			] ;
		]
	] .

ex:InvalidInstance1
  	ex:property "Some value" .</pre>
				</section>
				<section id="and">
					<h3>sh:AndConstraint</h3>
					<p>
						SHACL supports a high-level syntax for conjunctive constraints that can be used to test whether the <span class="term">focus node</span> has all out of several shapes.
						This is comparable to a logical "and" operator.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:shapes</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the following condition is false:
							The validation of the <span class="term">focus node</span> against all of the shapes in the <code>sh:shapes</code> list produces a validation result with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$shapes rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph, true) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(!?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; 0) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:AndConstraint</code> in a shape to verify
						that certain nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
						the minimum count, and a blank node shape that further constrains the maximum count.
						As shown here, <code>sh:AndConstraint</code> can be used to implement a specialization mechanism between shapes. 
					</p>
					<pre class="example" title="Shape with a conjunction">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:constraint [
		a sh:AndConstraint ;
		sh:shapes (
			ex:SuperShape
			[
				sh:property [
					sh:predicate ex:property ;
					sh:maxCount 1 ;
				]
			]
		)
	] .


ex:ValidInstance1
	ex:property "One" .

# Invalid: more than one property
ex:InvalidInstance2
	ex:property "One" ;
	ex:property "Two" .</pre>
				</section>
				<section id="or">
					<h3>sh:OrConstraint</h3>
					<p>
						SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether the <span class="term">focus node</span> has at least one out of several shapes.
						This is comparable to a logical "or" operator.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:shapes</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the following condition is false:
							The validation of the <span class="term">focus node</span> against all of the shapes in the <code>sh:shapes</code> list produces no validation results with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$shapes rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph, true) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count = 0) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:OrConstraint</code> in a shape to verify
						that certain nodes have at least one value of <code>ex:exampleProperty1</code>
						or at least one value of <code>ex:exampleProperty2</code>.
					</p>
					<pre class="example" title="Shape with a disjunction">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:OrConstraint ;
		sh:shapes (
			[
				sh:property [
					sh:predicate ex:exampleProperty1 ;
					sh:minCount 1 ;
				]
			]
			[
				sh:property [
					sh:predicate ex:exampleProperty2 ;
					sh:minCount 1 ;
				]
			]
		)
	] .
	
ex:OrConstraintExampleValidResource
	ex:exampleProperty1 ex:someValue .</pre>
				</section>
				<section id="ClosedShape">
					<h3>Closed Shapes (sh:ClosedShapeConstraint)</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any resource can in principle have values for any property.
						However, in some cases it makes sense to restrict which properties can be applied to resources.
						The SHACL core language includes a construct called <code>sh:ClosedShapeConstraint</code> that can be assigned to
						a shape via the property <code>sh:constraint</code> to indicate that valid resources must only have
						values for those properties that have been explicitly declared via <code>sh:property</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td><code>rdf:List</code> (members: <code>rdf:Property</code>)</td>
							<td>Optional list of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
						</tr>
					</table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has the <span class="term">focus node</span> as its
							<span class="term">subject</span> and a <span class="term">predicate</span> that is not explicitly enumerated as a <code>sh:predicate</code>
							of the <code>sh:property</code> constraints at the surrounding shape.
							If the argument <code>sh:ignoredProperties</code> is present then the properties enumerated in this list are also permitted.
							The produced <span class="term">validation result</span> must have the corresponding values of the triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<p>
						The core vocabulary includes an instance of <code>sh:ClosedShapeConstraint</code> called <code>sh:Closed</code>
						that can be used in places where no other arguments such as <code>sh:ignoredProperties</code> are needed.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ?predicate ?object
WHERE {
	$this ?predicate ?object .
	FILTER (NOT EXISTS {
		GRAPH $shapesGraph {
			$currentShape sh:property/sh:predicate ?predicate .
		}
	} &amp;&amp; (!bound($ignoredProperties) || NOT EXISTS {
		GRAPH $shapesGraph {
			$ignoredProperties rdf:rest*/rdf:first ?predicate .
		}
	}))
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:ClosedShapeConstraint</code> in a shape to verify
						that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
						The "ignored" properties <code>sh:nodeShape</code> and <code>rdf:type</code> would also be allowed.
					</p>
					<pre class="example" title="A closed shape">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:ClosedShapeConstraint ;
		sh:ignoredProperties (sh:nodeShape rdf:type) ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .
	
ex:ClosedShapeExampleValidResource
	ex:exampleProperty1 ex:someValue .
	
ex:ClosedShapeExampleInvalidResource
	ex:exampleProperty2 ex:someValue ;
	ex:someOtherProperty 42 .</pre>
				</section>
			</section>
		</section>
		
		<section id="shapesGraph">
			<h2>Declaring the Shapes Graph</h2>
			<p>
				A <span class="term">data graph</span> MAY link to one or more <span class="term">shapes graphs</span> via the property <code>sh:shapesGraph</code>.
				The subject of this predicate must be the graph resource, i.e. the name of the data graph in the dataset.
				The objects of this predicate must be IRI nodes, pointing at a named graph in the dataset.
				Tools may use this information to determine which shapes graph to use for validation.
				If present, tools SHOULD transitively follow any links from the shapes graph via the predicate <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a> to other graphs and use the resulting union graph as parameter to the validation process.
			</p>
			<p>
				In the following example, a tool may use the named graph <code>&lt;http://example.org/graph-shapes&gt;</code> and its imports as the <span class="term">shapes graph</span> when validating the given graph.
			</p>
			<pre class="example" title="A data graph declaring a shapes graph">
&lt;http://example.org/graph&gt;
	sh:shapesGraph &lt;http://example.org/graph-shapes&gt; .

ex:MyInstance
	a ex:MyClass .</pre>
		</section>
		
		<section id="results">
			<h2>Validation Results Vocabulary</h2>
			<p>
				The output of a SHACL constraint validation process is a set of <span class="term">validation results</span>.
				SHACL includes an RDF vocabulary to represent such results together with
				structural information that may provide guidance on how to fix a violation, as well as
				human-readable messages.
			</p>
			<p>
				The following code snippet represents a syntactically correct result that may have been produced by a constraint validation engine:
			</p>
			<pre class="example" title="A constructed validation result">
ex:ExampleConstraintViolation
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:MyCurrentNode ;
	sh:subject ex:MyCurrentNode ;
	sh:predicate ex:someProperty ;
	sh:object ex:someInvalidValue ;
	sh:message "Incorrect value: expected something else here." .</pre>
			<p>
				Validation results must be instances of the class <code>sh:ValidationResult</code>.
				Its superclass <code>sh:AbstractResult</code> defines the properties described in the following sub-sections.
				SHACL implementations may produce instances of other subclasses of <code>sh:AbstractResult</code>, for example
				to report successfully completed constraint checks or accumulated results.
			</p>
			<section id="results-focus-node">
				<h4>sh:focusNode</h4>
				<p>
					Validation results may have a single value for the property <code>sh:focusNode</code> to point to an
					IRI or blank node that has caused the result.
					This represents the <span class="term">focus node</span> that was validated when the validation result was produced.
				</p>
			</section>
			<section id="results-triple">
				<h4>sh:subject, sh:predicate and sh:object</h4>
				<p>
					Validation results are often caused by a single RDF triple, or a predicate in the context of a given subject or object.
					This information can be encoded via the properties <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>,
					each of which can have at most one value.
					<code>sh:predicate</code> can only be present if either <code>sh:subject</code> or <code>sh:object</code> have also been specified.
					If <code>sh:object</code> is unspecified, then the interpretation is that the result is caused by the subject/predicate combination.
					If <code>sh:subject</code> is unspecified, then the interpretation is that the result is caused by the object/predicate combination.
				</p>
			</section>
			<section id="results-source">
				<h4>sh:sourceConstraint, sh:sourceShape and sh:sourceTemplate</h4>
				<p>
					Validation results may point at one <code>sh:Constraint</code> that has caused
					the result, specified via the property <code>sh:sourceConstraint</code>,
					and at the <code>sh:Shape</code> defining the constraint, via <code>sh:sourceShape</code>.
					Validation results that were produced by a <a href="#template-constraints">template call</a> may
					point at the <code>sh:ConstraintTemplate</code> that caused the result.
				</p>
			</section>
			<section id="results-detail">
				<h4>sh:detail</h4>
				<p>
					The property <code>sh:detail</code> may link a (parent) result with one or more other
					(child) results that provide further details about the cause of the (parent) result.
					Depending on the capabilities of the constraint validation engine, this may include failures of
					nested constraints that have been validated via <code>sh:valueShape</code>.
				</p>
			</section>
			<section id="results-message">
				<h3>sh:message</h3>
				<p>
					Validation results may have values for the property <code>sh:message</code> to communicate
					additional textual details to humans.
					While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
				</p>
			</section>
			<section id="results-severity">
				<h3>sh:severity</h3>
				<p>
					Each validation result must have exactly one of the following values for the property <code>sh:severity</code>.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Severity</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:Info</code></td>
						<td>An informative message, not a violation.</td>
					</tr>
					<tr>
						<td><code>sh:Warning</code></td>
						<td>A non-critical constraint violation indicating a warning.</td>
					</tr>
					<tr>
						<td><code>sh:Violation</code></td>
						<td>A constraint violation that should be fixed.</td>
					</tr>
				</table>
			</section>
			<section id="severity">
				<h3>Declaring the Severity of a Constraint</h3>
				<p>
					Constraints can specify their severity level using the property <code>sh:severity</code>,
					which must point at one of the severity types.  <code>sh:Violation</code> is the default if unspecified.
					Constraints based on <a href="#template-constraints">templates</a> use the <code>sh:severity</code> declared at the template itself unless overridden at the constraint.
					The following example clarifies this.
				</p>
				<pre class="example" title="Declaring the Severity using sh:severity">
ex:MyShape
	a sh:Shape ;
	sh:property [
		# Violations of either minCount and datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# Violation of maxCount are produced as sh:Violations (which is the default for sh:maxCount)
		sh:predicate ex:myProperty ;
		sh:maxCount 1 ;
	] ;
.</pre>
			</section>
		</section>
		
		<div style="padding-top: 30px">
			<h1 style="font-size: 160%; font-weight: bold">Part 2: Advanced Features</h1>
			<p>
				Part 1 of this specification has introduced features that are built into the Core of SHACL.
				The goal of this Core was to provide a high-level vocabulary for common use cases to describe shapes.
				However, SHACL also provides mechanisms to go beyond the Core vocabulary and represent constraints and scopes with greater flexibility.
				These mechanisms are described in the sections of Part 2.
			</p>
		</div>
		
		<section id="native-constraints">
			<h2>Native Constraints</h2>
			<p>
				The property <code>sh:constraint</code> provides the most general mechanism to associate a constraint with a shape.
				The values of this property must be <span class="term">constraints</span> - instances of the class <code>sh:Constraint</code>.
				Note that the property <code>sh:property</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:PropertyConstraint</code>.
				The property <code>sh:inverseProperty</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:InversePropertyConstraint</code>.
			</p>
			<p>
				SHACL supports two types of general constraints:
			</p>
			<ul>
				<li>Constraints based on a high-level vocabulary (<a href="#template-constraints">templates</a>)</li>
				<li>Constraints based on a native executable (such as a SPARQL query)</li>
			</ul>
			<p>
				The following sub-sections are about the latter, while templates are covered at a later stage.
			</p>
			<section class="informative">
				<h3>An Example Native Constraint</h3>
				<p>
					For the sake of this example, we assume a data graph containing the following instances:
				</p>
				<pre class="example" title="Example ex:Country instances">
ex:ValidCountry
	a ex:Country ;
	ex:germanLabel "Spanien"@de .
  
ex:InvalidCountry
	a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<p>
					The following example illustrates the definition of a <span class="term">native constraint</span> based on a SPARQL query.
					The property <code>sh:sparql</code> is used to point at a SELECT query as explained in a later <a href="#native-constraints-sparql">section</a>.
				</p>
				<pre class="example" title="Example Shape with a native SPARQL constraint">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:constraint [
		sh:message "Values must be literals with German language tag." ;
		sh:sparql """
			SELECT $this ($this AS ?subject) (ex:germanLabel AS ?predicate) (?value AS ?object)
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .</pre>
				<p>
					The scope of the shape includes all instances of <code>ex:Country</code>.
					For those instances (represented by the variable <code>$this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
					and verifies that they are literals with a German language code.
					The output of the graph validation for the instances above is shown in the next example: 
				</p>
				<pre class="example" title="Example validation results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:InvalidCountry ;
	sh:subject ex:InvalidCountry ;
	sh:predicate ex:focusNode ;
	sh:object "Spain"@en ;
	sh:sourceShape ex:LanguageExampleShape ;
	...
]
</pre>
				<p>
					The SPARQL query returns result set rows for all bindings of <code>?value</code> that violate the constraint.
					A validation result is produced for each row in that result set, using <code>$this</code> as the <code>sh:focusNode</code> and <code>sh:subject</code>,
					<code>ex:germanLabel</code> as <code>sh:predicate</code> and the violating value as <code>sh:object</code>.
				</p>
				<p>
					In the example above, it is assumed that the existing SHACL engine is capable of evaluating native constraints using SPARQL, as described in the following section.
					Additional executable languages such as JavaScript may be provided based on other sets of properties like <code>ex:javaScript</code>,
					but that is outside of the scope of this specification.
				</p>
			</section>
			<section id="native-constraints-sparql">
				<h3>SPARQL-based Native Constraints</h3>
				<p>
					Native constraints are instances of <code>sh:NativeConstraint</code>, which is a subclass of <code>sh:Constraint</code>.
					However, the <code>rdf:type</code> triple of native constraints can be ommitted for typeless resources that are object of a <code>sh:constraint</code> triples.
					If a native constraint has a value for the property <code>sh:sparql</code> then it can be considered to be a <span class="term">native SPARQL constraint</span>.
					The SPARQL queries linked to a <span class="term">constraint</span> via <code>sh:sparql</code> must be string literals that can be parsed into legal SPARQL 1.1 queries	of the query form <code>SELECT</code>.
					Before parsing, a SHACL processor must pre-pend <code>PREFIX</code> statements for all namespace prefixes defined in the current <span class="term">shapes graph</span>.
				</p>
				<section id="sparql-constraints-prebound">
					<h4>Pre-bound Variables in SPARQL Constraints ($this, $shapesGraph, $currentShape)</h4>
					<p>
						When SPARQL constraints are executed, the engine must pre-bind values for the following variables with special meaning.
						The effect of this pre-binding is that all occurrences of these variables in the top-level query will have the provided
						values, similar to inserting a SPARQL VALUES clause into the beginning of the query, but also supporting blank nodes.
					</p>
					<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
						We need a suitable formal definition of what pre-binding means - the statement above with VALUES may not be entirely correct.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Variable</th>
							<th>Interpretation</th>
						</tr>
						<tr>
							<td><code>$this</code></td>
							<td>
								The <span class="term">focus node</span>.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">$shapesGraph</code></td>
							<td>
								The named graph containing the shape definitions (and possibly other data).
								Can be used as in <code>GRAPH $shapesGraph { ... }</code> to query shapes, constraints, background data
								and complex arguments such as <code>rdf:Lists</code>.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">$currentShape</code></td>
							<td>
								The currently validated shape.  Typically used in conjunction with <code>$shapesGraph</code>.
							</td>
						</tr>
					</table>
					<div class="issue" data-number="47" title="Access to $shapesGraph">
						There is no consensus yet if and under which conditions SPARQL queries can access the shapes graph.
						This document assumes that access exists.
					</div>
				</section>
				<section id="sparql-constraints-variables">
					<h4>Mapping of Result Variables to Validation Results</h4>
					<p>
						Each row of the result set produced by a SELECT query must be converted into one validation result resource.
						The properties of those resources are derived by the following rules, through a combination of result variables and the properties linked to the constraint itself.
						The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Production Rules</th>
						</tr>
						<tr>
							<td><code>sh:severity</code></td>
							<td>
								<ol>
									<li>For <span class="term">template constraints</span>, the value of <code>sh:severity</code> of the constraint node (template instance)</li>
									<li>The value of <code>sh:severity</code> of the subject of the <code>sh:sparql</code> triple</li>
									<li><code>sh:Violation</code> as default</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:focusNode</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>$this</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:subject</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?subject</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:predicate</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?predicate</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:object</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?object</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:message</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?message</code></li>
									<li>
										The values of <code>sh:message</code> of the subject of the <code>sh:sparql</code> triple.
										These values may reference any variable from the SELECT result variables via <code>{?varName}</code>.
										If the constraint is a template constraint, then the template's argument variables can also be used.
										The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
									</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceConstraint</code></td>
							<td>
								<ol>
									<li>The <span class="term">constraint</span> that was validated</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceShape</code></td>
							<td>
								<ol>
									<li>The <span class="term">shape</span> that was validated</li>
								</ol>
							</td>
						</tr>
					</table>
				</section>
				<section id="sparql-constraints-annotations">
					<h4>Injecting Annotation Properties into Validation Results</h4>
					<p>
						It is possible to inject additional <span class="term">annotation properties</span> into the validation result resources created for each row of the SELECT result sets.
						Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the subject holding the <code>sh:sparql</code> triple.
						The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value type</th>
							<th>Count</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>sh:annotationProperty</code></td>
							<td><code>rdf:Property</code></td>
							<td><code>1 (mandatory)</code></td>
							<td>The annotation property that shall be set</td>
						</tr>
						<tr>
							<td><code>sh:annotationVarName</code></td>
							<td><code>xsd:string</code></td>
							<td><code>0..1</code></td>
							<td>The name of the SPARQL variable to take the values from</td>
						</tr>
						<tr>
							<td><code>sh:annotationValue</code></td>
							<td></td>
							<td><code>0..unlimited</code></td>
							<td>Constant nodes that shall be used as values</td>
						</tr>
					</table>
					<p>
						If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the engine must copy the bindings for the given variable into the constructed validation results for the same row.
					</p>
					<p>
						The values of <code>sh:annotationProperty</code> must not be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
					</p>
					<p>
						Here is a slightly complex example, illustrating the use of result annotations.
					</p>
					<pre class="example" title="Constraint with an annotation">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:constraint [
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:sparql """
			SELECT $this ?subject (ex:property2 AS ?predicate) (?first AS ?object) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .
	
ex:ExampleRootResource
	sh:nodeShape ex:ShapeWithPathViolationExample ;
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
					<p>
						Which produces the following validation result resource:
					</p>
					<pre class="example" title="Constraint example result output">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:ExampleRootResource ;
	sh:subject ex:ExampleValueResource ;
	sh:predicate ex:property2 ;
	sh:object ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:constraint above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
				</section>
			</section>
		</section>
		
		<section id="template-constraints">
			<h2>Template Constraints</h2>
			<p>
				Native constraints in a language like SPARQL as introduced in the previous section typically provide a lot of flexibility.
				However, SPARQL-based constraints may also be hard to understand for some people, and may be repetitive.
				<span class="term">Templates</span> can be used to encapsulate and parameterize such native queries.
				<span class="term">Constraint templates</span> can be instantiated anywhere where a native constraint may appear (in particular, at <code>sh:constraint</code>).
				<span class="term">Scope templates</span> can be instantiated anywhere where a native scope may appear, at <code>sh:scope</code>.
				All of the constraint and scope types built into the SHACL Core are also represented as templates in the SHACL RDF vocabulary.
				Such templates form a high-level vocabulary that may also be directly interpreted ("hard-coded") without reliance on the fact that they are templates.
			</p>
			<p>
				Constraint templates are represented as IRI nodes that are instances of the class <code>sh:ConstraintTemplate</code>.
				Scope templates are represented as IRI nodes that are instances of the class <code>sh:ScopeTemplate</code>.
				SHACL also includes a more general superclass <code>sh:Template</code> that may be used for other kinds of templates (rules, stored queries etc).
				Well-defined, non-abstract templates must provide at least one <span class="term">body</span> using a property such as <a href="#sparql-templates"><code>sh:sparql</code></a>.
			</p>
			<section class="informative">
				<h3>An Example Template Constraint</h3>
				<p>
					The following example illustrates the definition of a constraint template based on a SPARQL query.
					It is a variation of the native example constraint from the previous section.
					That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
					Templates make it possible to generalize such scenarios, so that constants get substituted with <span class="term">arguments</span>.
					This allows the query logic to be reused in multiple places, without having to write any new SPARQL. 
				</p>
			<pre class="example" title="Constraint template based on SPARQL">
ex:LanguageConstraint
	a sh:ConstraintTemplate ;
	rdfs:label "Language constraint" ;
	rdfs:subClassOf sh:TemplateConstraint ;
	sh:argument [
		sh:predicate ex:predicate ;
		sh:valueClass rdf:Property ;
		rdfs:label "predicate" ;
		rdfs:comment "The property to validate the values of." ;
    ] ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		rdfs:label "language" ;
		rdfs:comment "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:sparql """
		SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
		WHERE {
			$this $predicate ?value .
			FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
		}
		""" .</pre>
				<p>
					Once a template has been defined, it can be instantiated as a constraint, as illustrated in the following example:
				</p>
				<pre id="TemplateLanguageExampleShape" class="example" title="Shape definition using ex:LanguageConstraint">
ex:TemplateLanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:constraint [
		a ex:LanguageConstraint ;
		ex:predicate ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:constraint [
		a ex:LanguageConstraint ;
		ex:predicate ex:englishLabel ;
		ex:lang "en" ;
	] .</pre>
				<p>
					The example shape above specifies that all values of <code>ex:germanLabel</code> must carry the language tag <code>de</code>
					while all values of <code>ex:englishLabel</code> must have <code>en</code> as their language.
					These details are specified via two instances of <code>ex:LanguageConstraint</code> that provide values for the arguments required by the template.
				</p>
				<p>
					The following sections introduce the properties that constraint templates may have.
					All of these properties except for <code>sh:sparql</code> are independent of SPARQL-based execution and apply
					to constraint templates based on other languages such as JavaScript too.
					A later <a href="#sparql-templates">section</a> provides additional details for SPARQL-based SHACL templates.
				</p>
			</section>
			<section id="template-arguments">
				<h3>Template Arguments</h3>
				<p>
					The arguments of a template are linked via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>, but the <code>rdf:type</code> triples of these instances can be omitted.
				</p>
				<p>
					Each <code>sh:Argument</code> must have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs.
					<span id="def-local-name">The <span class="term">local name</span> of a IRI is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the IRI, not immediately preceeded by the first colon in the IRI.</span>
					The local names of the values of <code>sh:predicate</code> must fulfill the following conditions (to ensure a correct mapping from arguments into SPARQL variables is possible):
				</p>
				<ul>
					<li>The <span class="term">local name</span> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Argument</code> for the same template (and its transitive superclasses) that has a <code>sh:predicate</code> with the same <span class="term">local name</span></li>
				</ul>
				<p>
					An <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
				</p>
				<p>
					An <code>sh:Argument</code> may declare a default value via <code>sh:defaultValue</code>.
					For non-optional arguments, the engine must use the declared default value for template instances that do not define a value for this argument.
					Template instances can have at most one value for each argument predicate.
				</p>
				<p>
					An <code>sh:Argument</code> may declare one value for the property <code>sh:valueClass</code> or one value for
					<code>sh:datatype</code>, similar to their counterparts in property constraints.
					Likewise, an <code>sh:Argument</code> may specify a <code>sh:NodeKind</code> via <code>sh:nodeKind</code>.
					This can be used to communicate the expected value type of the argument in template instances.
					Some implementations MAY use this information to prevent the execution of a template with invalid arguments.
				</p>
			</section>
			<section id="template-instantiation">
				<h3>Template Instantiation</h3>
				<p>
					<code>sh:Template</code> is subclass of <code>rdfs:Class</code>, which means that templates can be instantiated via <code>rdf:type</code>.
					Such <span class="term">template instances</span> can be used as values of <code>sh:constraint</code>, among others, as demonstrated in an <a href="#TemplateLanguageExampleShape">example</a> above.
				</p>
				<p>
					Template instances are called <span class="term">complete</span> when they have values for all non-optional arguments.
					Only template instances that are complete will be validated - incomplete templates will be (silently) ignored during constraint validation.
				</p>
				<p>
					Constraint templates may be placed in a <code>rdfs:subClassOf</code> relationship with other templates.
					The implication of doing this is that when an instance of the superclass template is validated, then all (transitive) superclass templates will also be validated,
					assuming their arguments are <span class="term">complete</span>.
				</p>
			</section>
			<section id="template-labelTemplate">
				<h3>sh:labelTemplate</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used to suggest how instances of the template shall be rendered to humans.
					The <code>sh:labelTemplate</code> must be a string that can reference the arguments using the syntax <code>{?varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the argument.
					At display time, these <code>{?...}</code> blocks SHOULD be substituted with the actual values used in the template instance.
				</p>
			</section>
			<section id="template-property-constraints">
				<h3>Property Constraint Templates</h3>
				<p>
					Some constraints are about a specific property only, and SHACL provides the system properties <code>sh:property</code> and <code>sh:inverseProperty</code> for those cases.
					In order to define constraints that can be used similar to the built-in Core constraint properties such as <code>sh:minCount</code>,
					a SHACL template needs to declared to be a subclass of <code>sh:PropertyConstraint</code> (for <code>sh:property</code>) or <code>sh:InversePropertyConstraint</code> (for <code>sh:inverseProperty</code>).
					Such templates "inherit" the argument <code>sh:predicate</code>.
					This is illustrated in the following example.
				</p>
				<pre class="example" title="An example property constraint template with a shape that uses it">
ex:LanguagePropertyConstraint
	a sh:ConstraintTemplate ;
	rdfs:subClassOf sh:PropertyConstraint ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		rdfs:label "language" ;
		rdfs:comment "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:sparql """
		SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
		WHERE {
			$this $predicate ?value .
			FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
		}
		""" .

ex:TemplateLanguageWithPropertyConstraintExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:property [
		a ex:LanguagePropertyConstraint ;
		sh:predicate ex:germanLabel ;
		sh:datatype rdf:langString ;
		sh:maxCount 1 ;
		ex:lang "de" ;
	] .</pre>
				<p>
					As shown above, shapes can instantiate such templates via <code>sh:property</code>
					and mix custom constraint properties such as <code>ex:lang</code> with those from the SHACL Core vocabulary, such as <code>sh:maxCount</code>.
				</p>
			</section>
			<section id="template-validation-functions">
				<h3>Templates with a sh:validationFunction</h3>
				<p>
					Constraint templates that are instances of <code>sh:PropertyValueConstraintTemplate</code> or
					<code>sh:InversePropertyValueConstraintTemplate</code> (which are subclasses of <code>sh:ConstraintTemplate</code>) do not require an executable body (such a <code>sh:sparql</code>)
					if they instead point at a <code>sh:Function</code> via the property <code>sh:validationFunction</code>.
					These so called <span class="term">validation functions</span> must take an argument with the predicate <code>sh:value</code> as its first argument
					and return either <code>true</code> or <code>false</code>.
					This validation function must be used by a constraint validation engine to construct a procedure that iterates over all values of the (possibly inverse) property,
					and then runs a filter test using the function.  If the filter returns <code>false</code> then a validation result must be produced.
					Validation functions may take additional arguments, and the engine must fill them with the matching arguments from the surrounding template.
					The SHACL system vocabulary contains several examples of such validation functions, e.g. <code>sh:AbstractDatatypePropertyConstraint</code>.
				</p>
				<p>
					The following example defines a constraint template using a <span class="term">validation function</span> from a <a href="#ValidationFunctions">later section</a>.
				</p>
				<pre class="example" title="Template definition using a validation function">
ex:LanguageConstraint
	a sh:PropertyValueConstraintTemplate ;
	rdfs:label "Language constraint" ;
	rdfs:subClassOf sh:TemplateConstraint ;
	sh:argument [
		sh:predicate ex:predicate ;
		sh:valueClass rdf:Property ;
		rdfs:label "predicate" ;
		rdfs:comment "The property to validate the values of." ;
    ] ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		rdfs:label "language" ;
		rdfs:comment "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:validationFunction ex:hasLanguage .</pre>
			</section>
			<section id="sparql-templates">
				<h3>SPARQL-based Constraint Templates</h3>
				<p>
					If a <code>sh:Template</code> has a value for <code>sh:sparql</code>, then the corresponding instances need to follow the same execution rules as outlined for <a href="#sparql-constraints">SPARQL-based Constraints</a> and <a href="#sparql-constraints">SPARQL-based Scopes</a>.
					The only difference is that the SPARQL queries need to be executed with additional <span class="term">pre-bound</span> variables, derived from the arguments of the template.
					The names of those variables must match the <a href="#def-local-name"><span class="term">local name</span></a> of the argument predicates, including the arguments defined by any (transitive) superclasses of the template.
					For example, if an argument is represented with the predicate <code>ex:myArgument</code> then the variable <code>?myArgument</code> must be <span class="term">pre-bound</span> with the value of the argument in the template instance.
				</p>
				<p>
					If a <code>sh:PropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="algorithm">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	FILTER (!{validationFunction}(?object, {+ other matching arguments})) .
}</pre>
				<p>
					If a <code>sh:InversePropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="algorithm">
SELECT $this ?subject $predicate ($this AS ?object)
WHERE {
	?subject $predicate $this .
	FILTER (!{validationFunction}(?subject, {+ other matching arguments})) .
}</pre>
			</section>
		</section>
		
		<section id="general-scopes">
			<h2>General Scopes (sh:scope)</h2>
			<p>
				In addition to the scope classes introduced in the core section, such as <code>sh:PropertyScope</code>,
				SHACL provides facilities to define custom scopes.
				Similar to constraints, scopes may either have be <span class="term">native scopes</span> or be an instance of <code>sh:TemplateScope</code>.
				All this is analogous to how constraints work, but with the additional restrictions:
			</p>
			<ul>
				<li>All subjects of <code>sh:scope</code> triples must be IRIs</li>
				<li>The arguments of a scope template must not be blank nodes</li>
			</ul>
			<section id="sparql-scopes">
				<h3>SPARQL-based Scopes</h3>
				<p>
					The SPARQL queries linked to a <span class="term">scope</span> via <code>sh:sparql</code> must be of the query form <code>SELECT</code>, or a fragment that produces a valid <code>SELECT</code> query if wrapped by <code>SELECT ?this WHERE { ... }</code>.
					The SELECT queries must project to the result variable <code>?this</code>.
					The resulting scope consists of all distinct bindings for the variable <code>?this</code>.
				</p>
				<p>
					The SELECT queries must also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This constraint makes sure that engines can validate whether a given shape applies to a given focus node as part of the <a href="#operation-validateNode">validateNode</a> operation.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based scope that produces all persons born in the USA:
				</p>
				<pre class="example" title="SPARQL-based scope example">
ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		sh:sparql """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	sh:constraint ...</pre>
			</section>
		</section>
		
		<section id="functions">
			<h2>Functions</h2>
			<p>
				SHACL <span class="term">functions</span> define operations that produce an RDF node based on zero or more arguments and a dataset.
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<p>
				Functions must be declared as instances of the class <code>sh:Function</code>.
				Well-defined, non-abstract functions must provide at least one body property such as <a href="#sparql-functions"><code>sh:sparql</code></a>.
			</p>
			<section class="informative">
				<h3>An Example Function</h3>
				<p>
					The following example illustrates the definition of a <span class="term">function</span> based on a SPARQL query.
				</p>
				<pre class="example" title="SHACL function with a SPARQL body">
ex:exampleFunction
	a sh:Function ;
	rdfs:comment "Computes the sum of its two arguments ?arg1 and ?arg2." ;
	sh:returnType xsd:integer ;
	sh:argument [
		sh:predicate sh:arg1 ;
		sh:datatype xsd:integer ;
		rdfs:comment "The first operand" ;
	] ;
	sh:argument [
		sh:predicate sh:arg2 ;
		sh:datatype xsd:integer ;
		rdfs:comment "The second operand" ;
	] ;
	sh:sparql """
		SELECT ($arg1 + $arg2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Based on the declaration above, SPARQL engines with full SHACL support can handle expressions such as <code>ex:exampleFunction(40, 2)</code>, producing <code>42</code>.
				</p>
				<p>
					The following sections introduce the properties that all such functions may have.
					A later <a href="#sparql-functions">section</a> provides additional details for SPARQL-based SHACL functions.
				</p>
			</section>
			<section id="function-arguments">
				<h3>Function Arguments</h3>
				<p>
					The arguments of a function are linked to its <code>sh:Function</code> via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>, but their <code>rdf:type</code> triple can be omitted.
					Arguments are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?arg1, ?arg2)</code>.
				</p>
				<p>
					Each <code>sh:Argument</code> must have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs, and follow the same restrictions outlined for <a href="#template-arguments">Template Arguments</a>.
					Arguments are "inherited" from the superclasses of the function.
					For example if a superclass already declares <code>sh:arg1</code> then subclasses may only define <code>sh:arg2</code> etc.
				</p>
				<p id="function-arguments-ordering">
					The ordering of function arguments (e.g. for printing in SPARQL strings) is determined by their index.
					For each function, the indices must be 0, 1, 2 etc.  The index of each declared <code>sh:Argument</code>
					is determined as follows:
				</p>
				<ol>
					<li>The index of the built-in argument predicates <code>sh:arg1</code>, <code>sh:arg2</code> etc is their numeric name part minus 1, e.g. <code>sh:arg1</code> has index 0.</li>
					<li>The index of other argument predicates is the value of the property <code>sh:index</code> at the surrounding <code>sh:Argument</code>.</li>
					<li>The default index for all other cases is the number of other arguments. This means that non-built-in arguments without a <code>sh:index</code> will be placed at the end of the order.</li>
				</ol>
				<p>
					Each <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
					If an argument has been declared optional, then all succeeding arguments must also be declared optional.
				</p>
				<p>
					Similar to <a href="#property-constraints">Property Constraints</a>, each <code>sh:Argument</code> may declare one value for the property <code>sh:datatype</code> or one value for the property <code>sh:valueClass</code>.
					This can be used to communicate the expected value type of the argument in function calls.
					Some implementations MAY use this information to prevent the execution of a function with invalid arguments.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					the engine how to cast a native value into an RDF value type.
				</p>
			</section>
			<section id="function-cachable">
				<h3>sh:cachable</h3>
				<p>
					A <code>sh:Function</code> may have a property <code>sh:cachable</code> set to <code>true</code>.
					Functions that are marked as cachable must always return the same value for the same combination of arguments, regardless of the query graphs.
					Engines can use this information to cache and reuse previous function calls without repeatedly executing their body.
				</p>
			</section>
			<section id="ValidationFunctions">
				<h3>Validation Functions</h3>
				<p>
					It is a common design pattern for functions to take a value as input and validate whether that value fulfills certain conditions or not.
					In support of this pattern, SHACL supports <span class="term">validation functions</span>, which are instances of <code>sh:Function</code> that are also subclasses of <code>sh:ValidationFunctions</code>.
					From that superclass, these functions "inherit" the (first) argument <code>sh:value</code>.
					Validation functions may define additional arguments with <code>sh:index</code> values larger than 1.
					The following example illustrates a validation function for the running example of the <a href="#template-validation-functions">section on constraint templates</a>.
				</p>
				<pre class="example" title="A validation function">
ex:hasLanguage
	a sh:Function ;
	rdfs:subClassOf sh:ValidationFunctions ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:index 1 ;
		rdfs:label "language" ;
		rdfs:comment "The language to match against, e.g. \"de\"." ;
	] ;
	sh:returnType xsd:boolean ;
	sh:sparql """
  		ASK {
  			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang)) .
		}
		""" .</pre>
				<p>
					An example invocation of the function above is: <code>ex:hasLanguage("Spain"@en, "en")</code>, producing <code>true</code>.
				</p>
			</section>
			<section id="sparql-functions">
				<h3>SPARQL-based Functions</h3>
				<p>
					If a <code>sh:Function</code> has a value for <code>sh:sparql</code> then it can be regarded as a <span class="term">SPARQL-based function</span>.
					In the SPARQL query, the engine needs to <span class="term">pre-bind</span> variables based on the provided arguments of the function call.
					The SPARQL query must be of type ASK or SELECT.
					For ASK queries, the function's return value is the result of the ASK query execution.
					For SELECT queries, the function's return value is the first binding of the first result variable in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one row.
				</p>
				<p>
					Some execution engines may ignore the specified <code>sh:sparql</code> query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified <code>sh:sparql</code> query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the <code>sh:sparql</code> query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>

		<section id="operations">
			<h2>Supported Operations</h2>
			<div class="issue" title="Specification of Operations">
				It is undecided to what extent this (operations) section is needed, and to what level of detail it should be specified.
				For now we present some high-level functions, but more details would be useful.
			</div>
			<p>
				This section enumerates the basic operations that complete SHACL engines SHOULD support.
				The specification does not prescribe how these operations are exposed to the user of a SHACL system.
				The functions are written in Java, assuming the presence of the following basic interfaces:
			</p>
			<pre class="algorithm">
// Represents RDF nodes: literals, IRIs or blank nodes.
interface Node {
}

// Represents an RDF triple
interface Triple {
	Node getSubject();
	Node getPredicate();
	Node getObject();
}

// Represents an RDF Graph
interface Graph {
	// Find operation - each argument may be null to indicate a wildcard
	Set&lt;Triple&gt; find(Node subject, Node predicate, Node object);
}

interface Dataset {
	Graph getDefaultGraph();
	Graph getNamedGraph(String iri);
}</pre>
			<p>
				The code snippets also assume access to interfaces defining constants for the various namespaces used in the code.
				For example, the value of <code>SH.Shape</code> is the IRI String for the <code>sh:Shape</code> class.
			</p>
			<p>
				All operations have access to the following fields:
			</p>
			<table class="term-table" border="1" cellpadding="5">
				<tr>
					<th>Field</th>
					<th>Type</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>dataset</td>
					<td>Dataset</td>
					<td>The dataset to operate on, must have a default graph and contain the shapesGraph</td>
				</tr>
				<tr>
					<td>dataGraph</td>
					<td>Graph</td>
					<td>The default Graph of the dataset</td>
				</tr>
				<tr>
					<td>shapesGraph</td>
					<td>Graph</td>
					<td>The shapes Graph</td>
				</tr>
				<tr>
					<td>shapesGraphIRI</td>
					<td>String</td>
					<td>The IRI of the shapes Graph</td>
				</tr>
				<tr>
					<td>resultsGraph</td>
					<td>Graph</td>
					<td>The Graph that will contain the validation results after completion</td>
				</tr>
			</table>
			<p>
				All operations produce <span class="term">validation results</span>.
				For the sake of this specification, we assume that the validation results are represented as instances of
				<code>sh:ValidationResult</code> that are added to the <code>resultsGraph</code>.
				Actual implementations may use different data structures and result formats and input and output to these operations.
			</p>
			<section id="operation-validateGraph">
				<h3>validateGraph</h3>
				<p>
					This operation validates a whole data graph against all shapes associated with its resources, based on the available scope definitions.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>minSeverity</code></td>
						<td><code>String</code></td>
						<td>The IRI of the minimum severity, e.g. <code>SH.Violation</code> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<pre class="algorithm">
void validateGraph(String minSeverity) {
	for(Node shape : getAllInstances(iri(SH.Shape), shapesGraph)) {
		validateShape(shape, minSeverity);
	}
}</pre>
   			</section>
			<section id="operation-validateShape">
				<h3>validateShape</h3>
				<p>
					Validates all nodes that are in the scope of a given shape against the constraints of that shape.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>shape</code></td>
						<td><code>Node</code></td>
						<td>The Node representing the shape to validate</td>
					</tr>
					<tr>
						<td><code>minSeverity</code></td>
						<td><code>String</code></td>
						<td>The IRI of the minimum severity, e.g. <code>sh:Violation</code> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<pre class="algorithm">
void validateShape(Node shape, String minSeverity) {
	for(Node focusNode : getNodesInScopeOfShape(shape)) {
		validateNodeAgainstShape(focusNode, shape, minSeverity);
	}
}</pre>
   			</section>
			<section id="operation-validateNodeAgainstShape">
				<h3>validateNodeAgainstShape</h3>
				<p>
					Validates a given node against the constraints of a given shape.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>focusNode</code></td>
						<td><code>Node</code></td>
						<td>The focus Node to validate</td>
					</tr>
					<tr>
						<td><code>shape</code></td>
						<td><code>Node</code></td>
						<td>The Node representing the shape to validate</td>
					</tr>
					<tr>
						<td><code>minSeverity</code></td>
						<td><code>String</code></td>
						<td>The IRI of the minimum severity, e.g. <code>sh:Violation</code> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<pre class="algorithm">
boolean validateNodeAgainstShape(Node focusNode, Node shape, String minSeverity) {
	boolean hasResults = false;
	if(isNodeValidForFilterShapes(focusNode, shape)) {
		for(Node constraint : getConstraintsOfShape(shape)) {
			if(hasMinSeverity(constraint, shape, minSeverity)) {
				if(isNodeValidForFilterShapes(focusNode, constraint)) {
					hasResults |= validateNodeAgainstConstraint(focusNode, constraint, shape);
				}
			}
		}
	}
	return hasResults;
}</pre>
				<p>
					The function returns <code>true</code> if there has been at least one <span class="term">validation result</span> with the given minimum severity.
				</p>
				<p>
					The helper function <code>getConstraintsOfShape</code> produces a Set of all values of the properties
					<code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code> and <code>sh:argument</code>
					for the given shape node in the shapes graph.
				</p>
   			</section>
			<section id="operation-validateNodeAgainstConstraint">
				<h3>validateNodeAgainstConstraint</h3>
				<p>
					Validates a given node against a given constraints from a given shape.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>focusNode</code></td>
						<td><code>Node</code></td>
						<td>The focus Node to validate</td>
					</tr>
					<tr>
						<td><code>constraint</code></td>
						<td><code>Node</code></td>
						<td>The constraint to validate</td>
					</tr>
					<tr>
						<td><code>shape</code></td>
						<td><code>Node</code></td>
						<td>The Node representing the shape containing the constraint</td>
					</tr>
				</table>
				<pre class="algorithm">
boolean validateNodeAgainstConstraint(Node focusNode, Node constraint, Node shape) {
	if(isNativeConstraint(constraint, shape)) {
		return executeNativeConstraint(constraint, shape, focusNode);
	}
	else {
		boolean hasResult = false;
		for(Node template : getAllTypes(constraint, shapesGraph)) {
			if(hasType(template, iri(SH.ConstraintTemplate), shapesGraph)) {
				hasResult |= executeTemplateConstraint(constraint, template, shape, focusNode);
			}
		}
		return hasResult;
	}
}</pre>
				<p>
					The function returns <code>true</code> if there has been at least one <span class="term">validation result</span> with the given minimum severity.
				</p>
   			</section>
			<section id="operation-validateNode">
				<h3>validateNode</h3>
				<p>
					Validates a given node against all shapes that it is in the scope of.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>focusNode</code></td>
						<td><code>Node</code></td>
						<td>The focus Node to validate</td>
					</tr>
					<tr>
						<td><code>minSeverity</code></td>
						<td><code>String</code></td>
						<td>The IRI of the minimum severity, e.g. <code>sh:Violation</code> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<pre class="algorithm">
boolean validateNode(Node focusNode, String minSeverity) {
	boolean hasResult = false;
	for(Node shape : getShapesWithNodeInScope(focusNode)) {
		hasResult |= validateNodeAgainstShape(focusNode, shape, minSeverity);
	}
	return hasResult;
}</pre>
				<p>
					The function returns <code>true</code> if there has been at least one <span class="term">validation result</span> with the given minimum severity.
				</p>
   			</section>
			<section id="defaultValueType">
				<h2>Validation of shapes graphs and the sh:defaultValueType property</h2>
				<p>
					The SHACL system vocabulary itself is using shapes, allowing SHACL constraint validation to be executed on shapes graphs, e.g. to validate the syntax of shape definitions.
					However, some system properties such as <code>sh:property</code>, <code>sh:filterShape</code> and <code>sh:argument</code> may have untyped blank nodes or IRIs as their values.
					If, for example, a value of <code>sh:property</code> is a blank node that does not have any <code>rdf:type</code>, then the assumption is that the blank node has type <code>sh:PropertyConstraint</code>.
					Unless these implicit triples are present in the data graph, constraint validation will not apply the constraints defined for <code>sh:PropertyConstraint</code>.
				</p>
				<p>
					If an engine intends to validate the syntax of a SHACL shapes graph itself, it should (temporarily) add the missing <code>rdf:type</code> triples.
					The SHACL system vocabulary includes some helper triples using the predicate <code>sh:defaultValueType</code> to specify the default <code>rdf:type</code> for certain properties.
					For example, the default value type of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
					These triples can be queried by a pre-processor to construct the missing type triples for the affected nodes.
					SHACL includes a template <code>sh:DefaultValueTypeRule</code> which encapsulates a SPARQL query that can be used for that purpose:
				</p>
				<pre class="algorithm">
CONSTRUCT {
	?node a ?defaultValueType .
}
WHERE {
	?predicate sh:defaultValueType ?defaultValueType .
	?anySubject ?predicate ?node .
	FILTER (NOT EXISTS { ?node a ?anyType }) .
}</pre>
				<p>
					The operations in this section assume that these default value types are present in the shapes graph, e.g.
					simplifying the test whether a given node is a <code>sh:NativeConstraint</code>.
				</p>
			</section>
		</section>

		<section id="entailment">
			<h3>Entailment</h3>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be actviated on the data graph.
				However, the property <code>sh:entailment</code> can be used to instruct a SHACL engine to ensure that a given entailment is activated.
				The values of <code>sh:entailment</code> must be IRIs, with common use cases covered by [[!sparql11-entailment]].
				The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.
			</p>
			<p>
				If the engine is not capable of supporting the given entailment regime, then it must produce a <span class="term">failure</span>.
				Standard-compliant SHACL implementations are not required to support any entailment regimes.
			</p>
		</section>
		
		<div style="padding-top: 30px">
			<h1 style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>
		
		<section id="terms" class="appendix">
			<h2>Glossary of Key Concepts</h2>
			<section id="term-Shape">
				<h3>Shape</h3>
				<ul>
					<li>A <span class="term">shape</span> is represented by an RDF node belonging to the class <code>sh:Shape</code>.</li>
					<li>Can have zero or more <span class="term">constraints</span>.</li>
					<li>Can have zero or more <span class="term">scopes</span> that select the nodes that the shape applies to.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that the shape applies to.</li>
				</ul>
			</section>
			<section id="term-Constraint">
				<h3>Constraint</h3>
				<ul>
					<li>A <span class="term">constraint</span> is represented by an RDF node belonging to the class <code>sh:Constraint</code>.</li>
					<li>Are either <span class="term">native constraints</span> (e.g. based on a SPARQL query) or <span class="term">template constraints</span>.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that constraint applies to.</li>
					<li>Are validated against nodes in an RDF graph (or dataset).</li>
				</ul>
			</section>
			<section id="term-Validation">
				<h3>Constraint Validation</h3>
				<ul>
					<li><span class="term">Validation</span> of <span class="term">Constraints</span> checks for the presence or absence of certain triples in an RDF graph (or dataset)</li>
					<li>Produces results, including informational results, warnings, and violations.</li> 
				</ul>
			</section>
			<section id="term-FocusNode">
				<h3>Focus Node</h3>
				<ul>
					<li>A <span class="term">Focus Node</span> is an RDF node in a graph that is passed into the <span class="term">validation</span> of a constraint.</li>
					<li>Represented using the variable <code>?this</code> in SPARQL.</li>
				</ul>
			</section>
			<section id="term-Scope">
				<h3>Scope</h3>
				<ul>
					<li>A <span class="term">Scope</span> is a declarative mechanism to select <span class="term">Focus Nodes</span> from a given graph.</li>
					<li>There are individual scopes (<code>sh:nodeShape</code>), class-based scopes (<code>sh:scopeClass</code>, <code>rdf:type</code>) and general scopes (<code>sh:scope</code>).</li>
					<li>A general scope may be defined by either a SPARQL query or a template.</li>
				</ul>
			</section>
			<section id="term-FilterShape">
				<h3>Filter Shape</h3>
				<ul>
					<li>A <span class="term">filter shape</span> defines constraints that potential focus nodes need to fulfill before they are validated.</li>
					<li>A node passes a filter shape when the validation of the shape does not lead to validation results with severity <code>sh:Violation</code> or a failure.</li>
				</ul>
			</section>
			<section id="term-Template">
				<h3>Template</h3>
				<ul>
					<li>A <span class="term">Template</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used for Constraints or Scopes.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
			<section id="term-Function">
				<h3>Function</h3>
				<ul>
					<li>A <span class="term">Function</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used in SPARQL queries.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
		</section>
		
	</body>
</html>
